### 暑假期间 OI 笔记

> 须要退步抽身早！——《红楼梦》

---

#### 树上背包

> 写得比较随意，不怎么严格，不过理解起来还是挺容易的. 

##### 基本概念

定义**体积**—**价值**对 $(v,w)\ (v>0)$ 为**物品**. 经典的 **0/1 背包问题**，即给定 $n$ 个物品和背包容量 $V$，选择一些体积和恰为 $V$ 的物品，最大化价值和（若无合法方案可认为答案是 $-\infin$）. 目标复杂度 $O(nV)$. 

定义**泛化物品**为序列 $f\ (f_0=0;f_k=-\infin,\forall k<0)$，对于每个 $k$，该泛化物品可以充当普通物品 $(k,f_k)$. 泛化物品就是价值可以随占据空间不同而变化的物品. 

一个物品 $(v,w)$ 可看作泛化物品 $f$，其中 $f_v:=w$，$f_k:=-\infin\ (k>0\land k\ne v)$. 

多个物品可以等效于一个泛化物品. 具体地，对于体积 $k$，定义 $f_k$ 为选择一些体积和恰为 $k$ 的物品，其最大的价值和. 这样来看，只需要**合并全部物品成一个泛化物品**，就解决了 0/1 背包问题. 因此泛化物品通常也称**背包**. 

##### 背包合并

由上分析，对于两个背包 $f,g$，它们的**合并** $h$ 应当是某种最优结果，即 $h_k$ 表示总体积为 $k$ 时的最大总价值. **考虑为 $f,g$ 各分配多少体积**，有 $h_k:=\max\limits_{i+j=k}f_i+g_j$，即 $f$ 和 $g$ 的 $(\max,+)$ **卷积**. 这操作被称为**背包合并**，复杂度 $O(V^2)$. 特别地，若背包 $g$ 是普通物品 $(v,w)$，只有分量 $g_0$ 和 $g_v$ 不是 $-\infin$，此时 $h_k=\max\{f_k,f_{k-v}+w\}$，合并复杂度 $O(V)$. 对于 0/1 背包问题，只需要按任意顺序把 $n$ 个物品都合并入背包，总复杂度 $O(nV)$. 

综上所述，合并两个背包的复杂度是 $O(V^2)$，合并背包和物品的复杂度是 $O(V)$.（合并背包和完全物品的复杂度也是 $O(V)$.）背包的合并是它们的 $(max,+)$ 卷积. 

```cpp
/** 0/1背包代码示例 **/
int v[n],w[n]; // input
int f[V]; // output
for(int i=0;i<n;i++){
    int h[V];
    for(int k=0;k<V;k++)
        if(k-v[i]>=0) h[k]=max(f[k], f[k-v[i]]+w[i]);
        else          h[k]=f[k];
    copy(h,h+V,f);
}
```

由于 `h` 的更新只依赖 `h` 更靠前的位置，内层循环可以倒序枚举 `k`，省去临时数组 `h`：

```cpp
for(int k=V-1;k>=v[i];k--) tomax(f[k], f[k-v[i]]+w[i]);
```

##### 树上背包

给定 $n$ 个结点的有根树 $T$，根为 $1$. 对于点 $u$，把物品 $u$ 及 $u$ 的所有儿子的背包合并，再做**一定的处理**（不改变背包大小）得到 $u$ 子树的背包. 一般的**树上背包问题**即求 $T$ 的背包. 容易发现，若不做处理，就退化成普通的 0/1 背包问题，这处理与具体题目有关，是树形态发挥作用的体现. 

显然，若最终所需的背包大小为 $V$，复杂度为 $O(nV^2)$，其中 $O(n)$ 为背包合并的次数，$O(V^2)$ 为一次合并的复杂度（因为必须**按树形态自下向上合并**，无法调整合并顺序使每次并入单个物品）. 

我们还能继续优化. 注意到之前采取的背包大小是固定的 $V$，而大多数时候 $v_u$ 远小于 $V$（题目中常见 $v_u=1$），所以当子树总体积较小时做了许多无用计算. 事实上，只需要采用**变长**的背包（$u$ 子树的背包大小为 $\min\{V,s_u\}$，其中 $s_u$ 表示子树 $u$ 结点的体积和），我们能以 $O(s_1V)$ 的复杂度求解树上背包.（注意这一定更优，因为总有 $s_1\le nV$，比 $V$ 还大的物品没有作用.）

> 由于这种思路非常自然，复杂度很符合直觉，证明从略. 

##### 例题

###### 洛谷 P3177

定义背包：$f_i$ 表示选 $i$ 黑点、其他为白点时，这部分的所有边的**全部**贡献（的最大值）——并非这部分的所有点两两贡献和，而是包括“对外”的路径. 这贡献是确定的，因为无论外部的点如何排布，其数量只和 $i$ 有关，因此可以计算出边的贡献. 

假设 $u$ 子树的背包 $f$ 已经求得，若 $u$ 为根，则 $f_k$ 就是答案. 否则，设该子树的大小为 $s$，其与父亲相连的边为 $w$. **向子树 $u$ 加入边 $w$**，可计算出边 $w$ 的贡献为 $w(i(k-i)+(s-i)(n-k-s+i))$. 将 $f_i$ 加上这个值就得到“**带柄子树**”的背包. 

对于点 $u$，单独这个点的背包 $f$ 为 $f_0=f_1=0$. 仅需把它和所有“带柄子树”的背包合并，就得到 $u$ 子树的背包. 

值得注意的是，这道题**不能对多组不同的 $k$ 给出结果**，因为边贡献的计算是含全局常量 $k$ 的. 最终在根的 $f$ 中，除了 $f_k$ 都是废值. 
